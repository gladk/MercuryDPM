// This file is part of MercuryDPM.
// 
// MercuryDPM is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// MercuryDPM is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with MercuryDPM.  If not, see <http://www.gnu.org/licenses/>.
// 
// Copyright 2013 The Mercury Developers Team
// For the list of developers, see <http://www.MercuryDPM.org/Team>
////////////////////////////////////////////////////////////////////////////////////////////////////
///This function outputs the location and velocity of the particle in a format the xballs progream can read  
///////////////////////////////////////////////////////////////////////////////////////////////////
//icc means included cc file
void DPMBase::outputXBallsDataParticle(const unsigned int i,const unsigned int format, std::ostream& os) const
{
    //getDataFile().precision(14);
    ///\todo{changes in *.icc files are not immediately regognized by the makefile!}
    //This outputs the data about particle i again to the file.
    switch (format)
    {
        case 8:
            {
            if (getSystemDimensions() == 1)
            {
                os << particleHandler.getObject(i)->getPosition().X << " 0 " << particleHandler.getObject(i)->getVelocity().X << " 0 " << particleHandler.getObject(i)->getRadius() << " 0 0 0" << std::endl;
                break;
            }
            else
            {
                Vec3D angle = particleHandler.getObject(i)->getOrientation();
                os
                << particleHandler.getObject(i)->getPosition().X << " "
                        << particleHandler.getObject(i)->getPosition().Y << " "
                        << particleHandler.getObject(i)->getVelocity().X << " "
                        << particleHandler.getObject(i)->getVelocity().Y << " "
                        << particleHandler.getObject(i)->getRadius() << " "
                        << -angle.Z << " " // negative b/c we are plotting (x,y) coordinates on the xz-axis of xballs
                        << -particleHandler.getObject(i)->getAngularVelocity().Z << " "
                        << getInfo(*particleHandler.getObject(i)) << std::endl;
            }
            break;
        }
        case 14:
            {
            Vec3D angle = particleHandler.getObject(i)->getOrientation();
            os
                    << particleHandler.getObject(i)->getPosition().X << " "
                    << particleHandler.getObject(i)->getPosition().Y << " "
                    << particleHandler.getObject(i)->getPosition().Z << " "
                    << particleHandler.getObject(i)->getVelocity().X << " "
                    << particleHandler.getObject(i)->getVelocity().Y << " "
                    << particleHandler.getObject(i)->getVelocity().Z << " "
                    << particleHandler.getObject(i)->getRadius() << " "
                    << angle.X << " " // negative b/c we are plotting (x,y) coordinates on the xz-axis of xballs
                    << angle.Y << " " // negative b/c we are plotting (x,y) coordinates on the xz-axis of xballs
                    << angle.Z << " " // negative b/c we are plotting (x,y) coordinates on the xz-axis of xballs
                    << particleHandler.getObject(i)->getAngularVelocity().X << " "
                    << particleHandler.getObject(i)->getAngularVelocity().Y << " "
                    << particleHandler.getObject(i)->getAngularVelocity().Z << " "
                    << getInfo(*particleHandler.getObject(i)) << std::endl;
            break;
        } //end case 3
        default:
            {
            std::cerr << "format not found" << std::endl;
            break;
        }
    } //end switch statement
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
///This automatically creates an xballs script to plot the data you have just generated///
/////////////////////////////////////////////////////////////////////////////////////////////////////
void DPMBase::writeXBallsScript() const
{
    std::stringstream file_name;
    std::ofstream script_file;
    file_name << getName() << ".xballs";
    script_file.open((file_name.str()).c_str());
    
    ///First put in all the script lines. All these lines do is move you to the correct directory from any location
    script_file << "#!/bin/bash" << std::endl;
    script_file << "x=$(echo $0 | cut -c2-)" << std::endl;
    script_file << "file=$PWD$x" << std::endl;
    script_file << "dirname=`dirname \"$file\"`" << std::endl;
    script_file << "cd $dirname" << std::endl;
    
    Mdouble scale;
    int format;
    
    if (getSystemDimensions() < 3)
    { // dim = 1 or 2
        format = 8;
        if (getXBallsScale() < 0)
        {
            scale = 1.0 / std::max(getYMax() - getYMin(), getXMax() - getXMin());
        }
        else
        {
            scale = getXBallsScale();
        }
    }
    else
    { //dim==3
        format = 14;
        if (getXBallsScale() < 0)
        {
            scale = 1.2 / std::max(getZMax() - getZMin(), getXMax() - getXMin());
        }
        else
        {
            scale = getXBallsScale();
        }
        
    }
    
    script_file << "../../XBalls/xballs -format " << format
            << " -f " << getDataFile().getFullName()
            << " -s " << scale
            << " -cmode " << getXBallsColourMode()
            << " -cmax -sort "
            << getXBallsAdditionalArguments()
    << " $*";
    ///\todo{thomas:why does vscale have to be integer?}
    if (getXBallsVectorScale() > -1)
    {
        script_file << " -vscale " << getXBallsVectorScale();
    }
    script_file.close();
    
    //This line changes teh file permision and give the owener (i.e. you) read, write and excute permission to the file.
#ifdef UNIX
    chmod((file_name.str().c_str()), S_IRWXU);
#endif
    
}

