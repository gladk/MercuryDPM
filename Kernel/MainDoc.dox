/*! \mainpage MercuryDPM Reference Manual

MercuryDPM is a code for discrete particle simulations. For more information checkout http://mercurydpm.org/

See also:\n
\ref OutputFiles \n 
\ref IntroductionToTheCode \n
\ref Tutorials \n
\ref Netbeans
*/

/*! \page OutputFiles Output Files

MercuryDPM creates three output files, $name.data, $name.fstat and $name.ene.
Here, $name stands for the problem name defined in the code.
Data is written at predefined time steps. 

Format of $name.data: This file is used for plotting particles. For each time step, the following format is used:
\verbatim
  First Line: N, time, xmin, ymin, zmin, xmax, ymax, zmax
  N Lines: x, y, z, vx, vy, vz, rad, q1, q2, q3, omex, omey, omez, xi
\endverbatim
where \p N is the number of particles,
  - \p time denotes the time step,
  - \p xmin, \p ymin, \p zmin, \p xmax, \p ymax, \p zmax denote the domain size,
  - \p x, \p y, \p z are the coordinates,
  - \p vx, \p vy, \p vz are the volocities,
  - \p rad is the radius,
  - \p q1, \p q2, \p q3 is the angular position,
  - \p omex, \p omey, \p omez is the angular velocity,
  - and \p xi is an additional variable the user can specify (default 0)

This is the (standard) output required for 3D data; for 2D data, only seven columns of particle information is written: x, y, z, vx, vy, vz, rad, xi

Format of $name.fstat: This file is mainly used for calculating stresses. For each time step, the following format is used:
\verbatim
  # time, info
  # info
  # info
  Line per contact: time, i, j, x, y, z, delta, deltat, fn, ft, nx, ny, nz, tx, ty, tz
\endverbatim
with time step time,
  - particle number \p i,
  - contact partner \p j (particles >= 0, walls < 0),
  - the contact point \p x, \p y, \p z,
  - overlap at the contact \p delta,
  - length of the tangential spring \p deltat,
  - absolute normal force \p |f^n|,
  - absolute tangential force \p |f^t|=|f-f^n|,
  - normal unit vector \p nx, \p ny, \p nz,
  - tangential unit vector \p tx, \p ty, \p tz.

Format of $name.ene: This file is mainly used for interpreting the time evolution. For each time step, the following format is used:
\verbatim
  time ene_gra ene_kin ene_rot ene_ela X_COM Y_COM Z_COM
\endverbatim
with
  - ene_gra \f$= \sum_i m_i Dot([x,y,z],-[gx,gy,gz])\f$ the gravitational potential energy (with gravity g=[gx,gy,gz]),
  - ene_kin \f$= \sum_i m_i v_i^2 / 2\f$ the translational kinetic energy,
  - ene_rot \f$= \sum_i I_i \omega_i^2 / 2\f$ the rotational kinetic energy (with inertia I),
  - ene_ela \f$= \sum_i (k_i \delta_i^2 + k_i^t (\delta_i^t)^2) / 2\f$ the potential energy from contact forces,  
  - X_COM, Y_COM, Z_COM the center of mass
*/

/*! \page IntroductionToTheCode Introduction to the Code

\section SECTION_InfoUsers Information for users of this application

\subsection SUBSECTION_GeneralInfo General Information

This code is written in C++ and does make use of both templates and the object oriented nature of C++. This basic architecture is to have a core kernel code (located in scr) that is general and flexible and then very small driver codes (located in DRIVERS) that pick out the parts of the kernel required to solve specific problems. 

\subsection SUBSECTION_DirUsers Directory Structure

At the top level you will find six main directories \n
        Configuration/ \n
        Documentation/ \n
        Drivers/ \n
        Kernel/ \n
        Scripts/ \n
        Tools/ \n
        XBalls/ \n

In the Documentation directory is located the documentation, i.e. this file. Please note, if you find no documentation there it can be generated by going into the DRIVERS/ direction and typing "make doc". If the documentation becomes corrupt the following will force it to regenerate "make docClean; make doc"

The Kernel direction contains the heart of the code and as a users you should not need to known much about it.

The Drivers directory has a series of subdirectories for example Tutorials/ that each contain a series of demo codes illustrating how to use the main src code. Typing "make fulltest" in the top level of drivers would perform checks on all parts of the code to confirm everything is functioning as intended.

Finally running a code will (in general) generate four files called some_name.data, some_name.xballs, some_name.stat. and some_name.ene. The files with .data extension contain all the position and velocity information for every particles. The .stat extension, contains macroscopic statistics about the problem (the information contained is semi-driver dependent). The .ene file contain some basic bulk information about the system i.e. centre of mass, total kinetic energy, total potential energy, etc. Finally .xballs extension is an a script file that to run to plot for .data output file using xballs.

\subsection SUBSECTION_TheScripts The Scripts

The directory contains a full scripts that are used by the selftest suite of MercuryDPM. You need worry about the contains of this directory at all; however, for the interested reader
- fpdiff.py : Calculated the floating point different between number in text file. This is part of the internal working of the selftest routine. This original version of this code was created for the oomph-lib project at  the University of Manchester.
- self_test : Makes calls to fpdiff.py passing the locations of newly create data and existing golddata. If writes error logs if something is different between the new data file and the golddata.

\subsection SUBSECTION_DriverDir Creating your own DRIVERS directory for your code

It you look in the DRIVERS directory you will see several subdirectories. These subdirectories contain collections of similar codes and, as a new user, you probably want to create a new directory for your own driver codes. To do this copy the TEMPLATE direction to you YOUR_DIR_NAME (if your are a developer and have access to svn repository it is advisable to svn copy to create your new DRIVERS directory)


\section Variables Variables and Equations 

-# global parameters: for details refer to MD class documentation.
	- time domain \f$[0,t_{\mbox{max}}]\f$, 
	- spatial domain \f$[x_{\mbox{min}},x_{\mbox{max}}] \times [y_{\mbox{min}},y_{\mbox{max}}] \times [z_{\mbox{min}},z_{\mbox{max}}]\f$,
	- number of particles \f$ N \f$,
	- number of (regular) walls \f$ N_{wall}\f$, 
	- number of periodic walls \f$ N_{wall,periodic}\f$
	- gravitational acceleration \f$ \vec{g}\f$,
	- Walls are defined by outward unit normal \f$ \vec{n}_{\mbox{w}}\f$ and position \f$ p_{\mbox{w}}\f$: \f$ \mbox{w} = \{\vec{x}:\ \vec{n}_{\mbox{w}} \cdot \vec{x} = p_{\mbox{w}} \}\f$
-# global variables:  for details refer to MD class documentation.
	- time \f$ t \f$, 
-# parameters for particle \f$ \mbox{P}_i \f$ : for details refer to CParticle class documentation
	- radius \f$ a_i \f$, 
	- mass \f$ m_i = \frac{4}{3} \pi a_i^3 \f$, 
	- inertia \f$ I_i = \frac{2}{5} m_i \f$,
 	- normal spring constant \f$ k \f$ (globally set)
	- normal dissipation coefficient \f$ \gamma \f$, 
	- tangential dissipation coefficient \f$ \gamma^t \f$, 
	- Coulomb friction coefficient \f$ \mu \f$
-# variables for particle \f$ \mbox{P}_i \f$: for details refer to CParticle class documentation
	- position \f$ \vec{r}_i(t)\f$,
	- velocity \f$ \vec{v}_i(t)\f$,
 	- angle \f$ \vec{\alpha}_i(t)\f$, 
 	- angular velocity \f$ \vec{\omega}_i(t)\f$.
-# initial values:
	- position \f$ \vec{r}_i(0) = \vec{r}_i^0 \f$, 
	- velocity \f$ \vec{v}_i(0) = \vec{v}_i^0 \f$, 
	- angle \f$ \vec{\alpha}_i(0)=\vec{0} \f$, 
	- angular velocity \f$ \vec{\omega}_i(0) = \vec{\omega}_i^0 \f$.
-# variables for each collision between particles \f$\mbox{P}_i\f$ and \f$\mbox{P}_j\f$:
 	- relative position \f$ \vec{r}_{ij} = \vec{r}_i - \vec{r}_j \f$,
	- normal direction \f$ \vec{n}_{ij} = \frac{\vec{r}_{ij}}{\|\vec{r}_{ij}\|}\f$,
 	- overlap \f$ \delta_{ij} = (\vec{a}_i - \vec{a}_j) - \vec{r}_{ij}\f$,
 	- relative velocity \f$ \vec{v}_{ij}=\vec{v}_i-\vec{v}_j + (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_i + (a_j-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_j \f$
 	- relative normal velocity \f$ v_{ij}^n = - \vec{v}_{ij} \cdot \vec{n}_{ij}$ ($= \dot{\delta}_{ij} \f$),
 	- normal force (spring-dashpot model) \f$ f_{ij}^n = k \delta_{ij} + \gamma v_{ij}^n \f$,
 	- relative tangential velocity \f$ \vec{v}_{ij}^t = \vec{v}_{ij} - v_{ij}^n \vec{n}_{ij} \f$,
 	- tangential direction \f$ \vec{t}_{ij} = \frac{\vec{v}_{ij}^t}{\|\vec{v}_{ij}^t\|}\f$,
 	- tangential force (sliding friction model) \f$ f_{ij}^t = - \max( \gamma^t v_{ij}^t,\ \mu f_{ij}^n)\f$,
 	- collision force \f$ \vec{f}_{ij} = f_{ij}^n \vec{n}_{ij} + f_{ij}^t \vec{t}_{ij},\ \mbox{if } \delta_{ij}\leq 0,\ 0\  \mbox{else} \f$,
-# Variables for collisions between particle \f$ \mbox{P}_i \f$ and wall \f$ \mbox{w}_j \f$:
	- normal direction \f$ \vec{n}_{ij}^{wall} = - \vec{n}_{\mbox{w}_j}\f$,
 	- overlap \f$ \delta_{ij}^{wall} = \vec{a}_i - (p_{\mbox{w}_j} - n_{\mbox{w}_j} \cdot x)\f$,
 	- relative velocity \f$ \vec{v}_{ij}^{wall}=\vec{v}_i + (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_i \f$,
 	- all else is the same as for particle collisions
-# Force and torque calculations
\f[
\vec{f}_i = m_i \vec{g} + \sum_{j=1}^N \vec{f}_{ij} + \sum_{j=1}^{N_{wall}} \vec{f}_{ij}^{wall},
\f]
\f[
 \vec{t}_i = \sum_{j=1}^N (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{f}_{ij} + \sum_{j=1}^{N_{wall}} (a_i-\frac{\delta_{ij}^{wall}}{2}) \vec{n}_{ij}^{wall} \times \vec{f}_{ij}^{wall}.
\f]
-# Time integration
\f[
\vec{\dot{r}}_i = \vec{v}_i,\ m_i \vec{\dot{v}}_i = \vec{f}_i,\quad 
 \vec{\dot{\alpha}}_i = \vec{\omega}_i,\ I_i \vec{\dot{\omega}}_i = \vec{t}_i
\f]

\section Implementation Implementation
\subsection TimeStepping Time Stepping
Verlet integration for \f$ \vec{r}_i \f$, forward Euler for \f$ \vec{\alpha}_i \f$, \f$ \vec{\omega}_i \f$, fixed time step \f$ dt \f$.
*/

/*! \page Tutorials Fun with MercuryDPM (Guide for tutorials)
The idea behind these tutorials, listed below, is to help the user improve his/her rapport with coding and problem solving in MercuryDPM. Most of the tutorials are designed to solve a simple problem. Each tutorial illustrates a new feature of MercuryDPM and gradually builds up on its level of difficulty.\n
\n
Note: In case of any typos or suggestions for new tutorials, please do not hesitate to contact the MercuryDPM team.

\section T1 T1: Particle motion in outer space
\image html Tutorials/T1/T1_fig1_particle.jpg Particle moving with a constant velocity in outer space.
###Problem description: 
File \b T1.cpp is setup to simulate a particle moving with a constant velocity in the absence of gravity, i.e. \f$ g= 0 m/s^2\f$. Below we describe each bit of the \b T1.cpp in detail.\n

###Headers:
To setup this problem code, below are the necessary headers (from the kernel) and the standard libraries, we include in \b T1.cpp. 
\snippet Drivers/Tutorials/T1.cpp T1:headers
Details concerning the above included headers (from the kernel) can be found in

###Class Tutorial1:
A class named \a Tutorial1 inherits from \a Mercury3D and is defined as below
\snippet Drivers/Tutorials/T1.cpp T1:class
The below function creates and sets up  the problems’ initial conditions
\code void setupInitialConditions()\endcode

###How to create a particle?
A particle is created and copied in a manner shown below
\snippet Drivers/Tutorials/T1.cpp T1:createParticle
\a p0 is an instance of the class \a BaseParticle and its properties like radius, initial position and velocity are set as above. The bit \code particleHandler.copyAndAddObject(p0)\endcode creates the particle \a p0 and adds a copy of it needed for the simulation.

###Main function:
In the main function, 
\# Problem properties, such as gravity, spatial dimensions (x,y,z), total run time are set as below
\snippet Drivers/Tutorials/T1.cpp T1:problemSetup
\# A particle can be of any type. There exist a variety of particle types, e.g. glass, plastic etc. Each of them behave differently when in action. Initially, when a particle is created, it attains the properties of a default species type with ‘0’ as its index. However, one can changes the species properties, as below.
\snippet Drivers/Tutorials/T1.cpp T1:speciesProp
\# Data output is vital to analyse simulations, which leads to defining ways to save the simulation data for post processing.\n
The simulations generate several types of data files. See \ref OutputFiles.\n
Below we set the flags corresponding to each data file type.
\snippet Drivers/Tutorials/T1.cpp T1:output
\# For XBalls users, additional display options can be set as below
\snippet Drivers/Tutorials/T1.cpp T1:visualOutput  
\# After all the simulation parameters are set, we reach a point where we put all the above bits of code in action by the following statements
\snippet Drivers/Tutorials/T1.cpp T1:solve
To see the above snippets as a whole, goto \ref T1code

\section T2 T2: Particle motion on earth
\image html Tutorials/T2/T2_fig1_particle.jpg Particle falling due to gravity.
####Problem descritpion:
In \b T2.cpp, we simulate a particle when dropped under the influence of gravity, \f$ g = 9.81 m/s^2\f$. Basically this is an extension of \b T1.cpp with few minor changes. All we need to do is change the following \n
- initial particle position and velocity in Class Tutorial2
\code
p0.setPosition(0.5*getXMax(),0.5*getYMax(),getZMax());
p0.setVelocity(Vec3D(0.0,0.0,0.0));
\endcode
- gravity vector in the main function of \b T2.cpp
\code
problem.setGravity(Vec3D(0.0,0.0,-9.81));
\endcode

To see the whole code with the above snippets included, goto \ref T2code

\section T3 T3: Bouncing ball (elastic)
\image html Tutorials/T3/T3_fig1_particle_wall.jpg Particle bouncing off the blue wall.
####Problem description: 
In \b T3.cpp, we simulate a particle bouncing off a wall assuming the collision between the particle and the wall is elastic. By elastic we mean that the particle velocity before and after collision remains the same. Implying that the restitution coefficient is unity. Additionally, we will learn how to add a wall over which the ball bounces.

####Headers:
\snippet Drivers/Tutorials/T3.cpp T3:headers
In order to add a wall to our problem setup we need to consider including the header 
\code #include “Walls/InfiniteWall.h” \endcode

#### Class Tutorial3:
\snippet Drivers/Tutorials/T3.cpp T3:class
The above class is basically an extension when compared to Class Tutorial1 or Class Tutorial2. Only difference being the addition of the wall which is done as shown in the snippet below
\snippet Drivers/Tutorials/T3.cpp T3:infiniteWall
The above set of statements, create and place the wall at \f$ Z_{min} \f$.\n 

Note: Don’t forget to include the InfiniteWall.h header, as shown in the header section. In some sense, creation and addition of a wall is similar to creation and addition of a particle.

#### Main function:
As usual, the problem is setup in the main function, see \ref T3code.

\section T4 T4: Bouncing ball with dissipation (inelastic)

####Problem description:
In \b T4.cpp, the difference between an elastic and inelastic collision between a particle and a wall is illustrated. The only difference between \b T3.cpp and \b T4.cpp is the value of the restitution coefficient. In \b T4.cpp, the coefficient of restitution is set to
\code double rc = 0.88; // restitution coefficient \endcode
See \ref T4code for more details.

\section T5 T5: Elastic collision (2 particles)
\image html Tutorials/T5/T5_fig1_two_particles.jpg Particles moving towards each other.
####Problem description:
So far, in the above tutorials, we have seen how a particle and a wall interact during a collision.\n
In this tutorial, we illustrate how two particles interact using \b T5.cpp. For this purpose, we need two particles.\n
The particles may or may not be of the same species type. But, here we shall assume they are of same species and same size.\n
As usual, we begin with including the required headers
####Headers:
\snippet Drivers/Tutorials/T5.cpp T5:headers

####Class Tutorial5:
\snippet Drivers/Tutorials/T5.cpp T5:class
On comparison between the above class and Class Tutorial1, we see how an additional particle is added. In the above class, in function 
\code void setupParticleInitialConditions(){} \endcode
two particles are created, and positioned oppositely apart at a certain distance between them. Both the particles, have a certain velocity directing them towards each other. 

####Main function:
Similar to \b T1.cpp, the problem is setup in \ref T5code

\section T6 T6: Elastic collisions with periodic boundaries
\image html Tutorials/T6/T6_fig1_perboun_two_particles.jpg (a) Illustrates the idea behind periodic boundaries, particle exiting boundary b2 re-enters through boundary b1 \n (b) Illustrates the problem setup.
####Problem description:
In the previous tutorial, we illustrated elastic collision between two particles of same type and size traveling towards each other.\n
In order to have multiple collisions, in the problem setup as Tutorial 5, we will use periodic boundaries in X.

####Headers:
\snippet Drivers/Tutorials/T6.cpp T6:headers
Above are the headers necessary for this problem.

####Class Tutorial6:
\snippet Drivers/Tutorials/T6.cpp T6:class
In the Class Tutorial6\n
(i) we create two particles of same type and different sizes.\n
(ii) we setup periodic boundaries in X-direction as
\snippet Drivers/Tutorials/T6.cpp T6:periodicBoundary

Note:\n
To create periodic boundaries one has to include the header ‘Boundaries/PeriodicBoundary.h’.\n
Be aware that the periodic boundary is not the same as an infinite wall.

####Main function:
Similar to \b T5.cpp, the problem is setup to solve, see \ref T6code

\section T7 T7: Motion of a particle in a two dimensional (2D) box
\image html Tutorials/T7/T7_fig1_particle_2Dbox.jpg Particle motion in a box (blue and black denote the walls).
####Problem description:
In previous tutorials, we have seen how a particle interacts with a wall and itself. In this tutorial, we will learn to design boxes of different shapes by using more than one wall. As an example, in absence of gravity, we will simulate a particle moving in a two dimensional square shaped box. We consider two dimensions only for the sake of simplicity.  

In Tutorial 3, we have shown you how to setup a wall. This tutorial builds itself on the same idea i.e. setting up walls.
####Headers:
\snippet Drivers/Tutorials/T7.cpp T7:headers
We use the same headers as used in Tutorial 3.

####Class Tutorial7:
\snippet Drivers/Tutorials/T7.cpp T7:class
In this class, we setup a 2D square shaped box or a polygon by adding more walls as shown above. In total, we have 4 walls forming our box within which the particle will traverse.

Note: As we simulate in 2D, no walls are set in z-direction.

####Main function:
As our simulation is two dimensional, we set the system dimensions as 2
\code problem.setSystemDimensions(2);\endcode

Complete code for the above problem description can be found in \ref T7code
 
\section T8 T8: Motion of a particle in a box with an obstacle
\image html Tutorials/T8/T8_fig1_particle_2Dbox_obstacle.jpg
####Problem description:
We extend the problem setup of Tutorial 7, by adding a rectangular block as shown in the above figure. To create this block of wall or obstacle, we will use the Class FiniteWall. Before we go ahead it is advised to know the difference between an infinite wall and finite wall, see \ref WallTypes. As an example, we create an obstacle using a set of finite walls and place it within the box created using a set of infinite walls. See the above figure.
####Headers:
\snippet Drivers/Tutorials/T8.cpp T8:headers
####Class Tutorial8:
\image html Tutorials/T8/T8_fig2_finitewall.jpg
The class Tutorial7 from the previous tutorial is extended by adding the finite wall setup. See the below snippet.
\snippet Drivers/Tutorials/T8.cpp T8:finiteWall
####Main function:
Similar to Tutorial 7, the above described problem is setup in \ref T8code

\section T9 T9: Motion of a ball over an inclined plane (Sliding + Rolling)
\image html Tutorials/T9/T9_fig1_particle_slid_roll_incline.jpg


####Problem description:
####Headers:
####Class Tutorial9:
####Main function:

\section data2pvd Using ParaView with MercuryDPM
Mercury produces several files by default. XBalls has previously always been used to visualize data.
Recently a ParaView output file writer has also been written by the team. By using the tool 'data2pvd',
it is possible to convert a Mercury 3D .data file to a ParaView .pvd file and several VTK .vtu files.
####Creating some data:
For now any demo data is good enough. For a nice set of data, try running any of the simple demos; We will be using
chute_demo from ChuteDemos for this example. First, run the example
\code{.sh}
cd Drivers/ChuteDemos
./chute_demo
\endcode
After letting it run for a while, several files remain:\n
      - chute_demo.data    containing particle information\n
      - chute_demo.ene     containing energy information\n
      - chute_demo.fstat   containing data for fstatistics\n
      - chute_demo.restart containing information to restart the simulation\n
      - chute_demo.xballs  which is a script to run xballs on the data files\n
For now, we are only interested in the .data files.

####Running data2pvd
Because system-wide installations of Mercury are rare, we have to invoke data2pvd
with a full path. Because data2pvd creates quite a lot of files, we recommend outputting to
a different directory to avoid cluttering your directory. First, we will create a directory
called hourglass_pvd, after which we will tell data2pvd to create the files into that directory.
\code{.sh}
mkdir chute_pvd
../../Tools/data2pvd chute_demo.data chute_pvd/chute
\endcode
This should take just a few seconds. The next step is starting paraview!
\code{.sh}
paraview
\endcode
You should start with a screen similar to the one provided below.
\image html Tutorials/ParaView/paraview.png
Next step is to open the file.
You can choose for either the chute.pvd file, to get the entire simulation,
or a single timestep by selecting the corresponding .vtu file. We'll be using
the entire simulation for now by opening chute.pvd.
\image html Tutorials/ParaView/openfile.png 
On the left, we can now see chute.pvd, below the builtin in the Pipeline browser.
Click apply to load it into the pipeline.
\image html Tutorials/ParaView/apply.png
Now we want to actually draw our particles. Open the 'filters' menu, then the 'common' menu and click 'Glyph'.
In this case, we want to draw all our particles, with the correct size and shape. Select the 'Sphere' shape,
select 'scalar' as Scale mode and use a factor of 2.0 (Mercury uses radii, while ParaView uses diameters).
Select 'All points' under masking to make sure all of our particles are actually rendered. Finally press 'Apply'
again.
\image html Tutorials/ParaView/zoom.png
Because we aren't focussed on our particles, click the 'Zoom to data' button.

Let's colour our particles based on the velocity. With the 'Glyph1' stage selected, scroll down in the properties
menu, until you find 'Colouring'. Select 'Velocities' and press the play button. There should now be particles
flying around.
\image html Tutorials/ParaView/run.png
Finally, it might be wise to rescale the colouring, to a sensible scale. Press the 'rescale' button to achieve this.
\image html Tutorials/ParaView/rescale.png

ParaView itself has endless possibilities and goes way beyond the scope of this document. Please consult the ParaView
documentation for more information.

\page Tcodes Codes for tutorials 

\section T1code Particle motion in outer space (code)
Return to tutorial \ref T1
\includelineno Drivers/Tutorials/T1.cpp
Return to tutorial \ref T1

\section T2code Particle motion on earth (code)
Return to tutorial \ref T2
\includelineno Drivers/Tutorials/T2.cpp
Return to tutorial \ref T2

\section T3code Bouncing ball - elastic (code)
Return to tutorial \ref T3
\includelineno Drivers/Tutorials/T3.cpp
Return to tutorial \ref T3

\section T4code Bouncing ball - inelastic (code)
Return to tutorial \ref T4
\includelineno Drivers/Tutorials/T4.cpp
Return to tutorial \ref T4

\section T5code Elastic collision - 2 particles (code)
Return to tutorial \ref T5
\includelineno Drivers/Tutorials/T5.cpp
Return to tutorial \ref T5

\section T6code Elastic collisions with periodic boundaries (code)
Return to tutorial \ref T6
\includelineno Drivers/Tutorials/T6.cpp
Return to tutorial \ref T6

\section T7code Motion of a particle in a two dimensional box (code)
Return to tutorial \ref T7
\includelineno Drivers/Tutorials/T7.cpp
Return to tutorial \ref T7

\section T8code Motion of a particle in a box with an obstacle (code)
Return to tutorial \ref T8
\includelineno Drivers/Tutorials/T8.cpp
Return to tutorial \ref T8

\section T9code Motion of a ball over an inclined plane (code)
Return to tutorial \ref T9
\includelineno Drivers/Tutorials/T9.cpp
Return to tutorial \ref T9

\page WallTypes Different types of walls
Walls are crucial in most of our problem setups and hence we have a variety of walls to suit the needs of our users.
\section InfWall Infinite Wall
\image html Walls/infiniteWall.jpg Infinite wall
A standard wall is a plane defined  as {x: normal*x=position}, with normal being the outward unit normal vector of the wall. A particle touches a standard wall if position-normal*x<=radius. Given the normal, a wall can be placed at any given position.\n
The black strip denotes the inner side of the wall. The particles interact with the wall along the blue strip.  
\section FinWall Finite Wall
\image html Walls/finiteWall.jpg A block of wall formed by set of infinite walls.
Finite wall is basically a set of infinite walls or A finite wall is convex polygon defined by a set of normals normal_i and positions position_i. For example, to create a polygonal obstacle (in 2D or 3D), we consider the a set of infinite walls and create the obstacle as an intersection of all the infinite walls. See above figure corresponding to finite walls. 

*/

/*! \page Netbeans Set up Netbeans editor to compile Mercury DPM
Writing, compiling, and debugging code is easier if you use a integrated development environment (IDE), such as NetBeans. 

To use MercuryDPM with Netbeans:
- Install Netbeans for C/C++ from https://netbeans.org/downloads/ and run the application.
- Click on <em>%File -> New Project</em> and click <em>Next</em>. 
- Specify the folder in which you have installed Mercury (e.g., <em>~/MercuryDPM/Alpha/</em>), select <em>Custom</em> configuration mode and click <em>Next</em>. 
- Click on <em>Run configure script in subfolder</em>, then click <em>Next</em> repeatedly until the button gets disabled. 
- Finally, click <em>Finish</em>. 

Now your project will be set up, which will take a few minutes. After that, you are ready to go.
*/
