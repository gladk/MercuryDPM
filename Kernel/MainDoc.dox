/*! \mainpage MercuryDPM Reference Manual

MercuryDPM is a code for discrete particle simulations. For more information checkout http://mercurydpm.org/

See also:\n
\ref OutputFiles \n 
\ref IntroductionToTheCode \n
\ref Tutorials
*/

/*! \page OutputFiles Output Files

MercuryDPM creates three output files, $name.data, $name.fstat and $name.ene.
Here, $name stands for the problem name defined in the code.
Data is written at predefined time steps. 

Format of $name.data: This file is used for plotting particles. For each time step, the following format is used:
\verbatim
  First Line: N, time, xmin, ymin, zmin, xmax, ymax, zmax
  N Lines: x, y, z, vx, vy, vz, rad, q1, q2, q3, omex, omey, omez, xi
\endverbatim
where \p N is the number of particles,
  - \p time denotes the time step,
  - \p xmin, \p ymin, \p zmin, \p xmax, \p ymax, \p zmax denote the domain size,
  - \p x, \p y, \p z are the coordinates,
  - \p vx, \p vy, \p vz are the volocities,
  - \p rad is the radius,
  - \p q1, \p q2, \p q3 is the angular position,
  - \p omex, \p omey, \p omez is the angular velocity,
  - and \p xi is an additional variable the user can specify (default 0)

This is the (standard) output required for 3D data; for 2D data, only seven columns of particle information is written: x, y, z, vx, vy, vz, rad, xi

Format of $name.fstat: This file is mainly used for calculating stresses. For each time step, the following format is used:
\verbatim
  # time, info
  # info
  # info
  Line per contact: time, i, j, x, y, z, delta, deltat, fn, ft, nx, ny, nz, tx, ty, tz
\endverbatim
with time step time,
  - particle number \p i,
  - contact partner \p j (particles >= 0, walls < 0),
  - the contact point \p x, \p y, \p z,
  - overlap at the contact \p delta,
  - length of the tangential spring \p deltat,
  - absolute normal force \p |f^n|,
  - absolute tangential force \p |f^t|=|f-f^n|,
  - normal unit vector \p nx, \p ny, \p nz,
  - tangential unit vector \p tx, \p ty, \p tz.

Format of $name.ene: This file is mainly used for interpreting the time evolution. For each time step, the following format is used:
\verbatim
  time ene_gra ene_kin ene_rot ene_ela X_COM Y_COM Z_COM
\endverbatim
with
  - ene_gra \f$= \sum_i m_i Dot([x,y,z],-[gx,gy,gz])\f$ the gravitational potential energy (with gravity g=[gx,gy,gz]),
  - ene_kin \f$= \sum_i m_i v_i^2 / 2\f$ the translational kinetic energy,
  - ene_rot \f$= \sum_i I_i \omega_i^2 / 2\f$ the rotational kinetic energy (with inertia I),
  - ene_ela \f$= \sum_i (k_i \delta_i^2 + k_i^t (\delta_i^t)^2) / 2\f$ the potential energy from contact forces,  
  - X_COM, Y_COM, Z_COM the center of mass
*/

/*! \page IntroductionToTheCode Introduction to the Code

\section SECTION_HowToUse How to use this documentation

\section SECTION_InfoUsers Information for users of this application

\subsection SUBSECTION_GeneralInfo General Information

This code is written in C++ and does make use of both templates and the object oriented nature of C++. This basic architecture is to have a core kernel code (located in scr) that is general and flexible and then very small driver codes (located in DRIVERS) that pick out the parts of the kernel required to solve specific problems. 

\subsection SUBSECTION_DirUsers Directory Structure

At the top level you will find three main directories \n
	DRIVERS/ \n
	scr/ \n
	DOCUMENTATION/

In the DOCUMENTATION direction is located the documentation, i.e. this file. Please note, if you find no documentation there it can be generated by going into the DRIVERS/ direction and typing "make doc". If the documentation becomes corrupt the following will force it to regenerate "make doc_clean; make doc"

The scr direction contains the heart of the code and as a users you should not need to known much about it.

The DRIVERS directory has a series of subdirectories for example Simple_MD/ that each contain a series of demo codes illustrating how to use the main src code. Typing "make selftest" in the top level of drivers would perform checks on all parts of the code to confirm everything is functioning as intended.

In each subdirectory (e.g. Simple_MD) there is a makefile that can be used to compile the individual codes. Note typing "make selftest" at this level will perform the test for that section of the code only. Also in subdirectory they is a second subdirectory call run/. If you move in this directory from here any driver can be run with the command "sc/quick_run driver_name". This command will compile and run driver_name.

Finally running a code will (in general) generate three files called some_name.data, some_name.disp and some_name.stat. The files with .data extension contain all the position and velocity information for every particles. The .stat extension, contains macroscopic statistics about the problem (the information contained is semi-driver dependent). Finally .disp extension is an a script file that to run to plot for .data output file using xballs.

\subsection SUBSECTION_TheScripts The Scripts

Along with this code you will find a directory called scripts. This contains a number of bash scripts designed to work with both the MD and finite volume programs. A brief summary of each script is as follows
- clean_run : The code has a feature to automatically number your runs (not yet documents, see parm_demo code for how to use). So the first time you run the code will be labelled 1, second 2, etc... Running clean_run CODENAME RUN_NUM will delete all files with run number RUN_NUM of driver code CODENAME. This does not prompt for each file, so please be careful with this command.
- fstat : To be documented
- go_run : This is internal script used by run and should not be called directly
- renumber_run : This changes the number of previous run. renumber_run CODENAME OLD_NUM NEW_NUM will change the number of all files associated with CODENAME run number OLD_NUM to be associated with run NEW_NUM. Please note again this command does not check it NEW_RUN exists so will delete any existing data associated with NEW_RUN.
- self_test : This is the script which does the work for 'make selftest'. It should never be called directly, please use make selftest.
- enestatistics : To be documented
- fstatatistics : To be documented
- kill_all : This kills all copies of a code running on a cluster. To use this commands please type the list of machine names on your cluster in the list filed at the top. Note the default list is more machine in the MSM group at the University of Twente
- report : This is the script which does the work of 'make report', please use make report instead of this command directly.
- find_code : This reports all codes belonging to your on your cluster, please again in this script you have to list the machine names of your cluster
- go_find_machine : Looks for spare ca[capacity on your cluster. To use this script please enter you machine list in list and the maxload per machine in maxload.
- make_movie : This script uses xball to make a movie. The command is called with make_movie SOMEFILE.disp, this will make a movie of the xballs output normally generated by the disp file SOMEFILE.disp.
- run : run MY_CODE will make and run the code called MY_CODE. This automatically looks for free space on your cluster using the information defined in go_find_machine
- fpdiff.py : Calculated the floating point different between number in text file. This is part of the internal working of the selftest routire. This original version of this code was created for the oomph-lib project at  the University of Manchester.
- go_make : This is internal script used by run.
- quick_run : Same as run, but runs the code on the local machine.

\subsection SUBSECTION_DriverDir Creating your own DRIVERS directory for your code

It you look in the DRIVERS directory you will see several subdirectories. These subdirectories contain collections of similar codes and, as a new user, you probably want to create a new directory for your own driver codes. To do this copy the TEMPLATE direction to you YOUR_DIR_NAME (if your are a developer and have access to svn repository it is advisable to svn copy to create your new DRIVERS directory)

\section InfoDev Information for developers of this application


\section Variables Variables and Equations 

-# global parameters: for details refer to MD class documentation.
	- time domain \f$[0,t_{\mbox{max}}]\f$, 
	- spatial domain \f$[x_{\mbox{min}},x_{\mbox{max}}] \times [y_{\mbox{min}},y_{\mbox{max}}] \times [z_{\mbox{min}},z_{\mbox{max}}]\f$,
	- number of particles \f$ N \f$,
	- number of (regular) walls \f$ N_{wall}\f$, 
	- number of periodic walls \f$ N_{wall,periodic}\f$
	- gravitational acceleration \f$ \vec{g}\f$,
	- Walls are defined by outward unit normal \f$ \vec{n}_{\mbox{w}}\f$ and position \f$ p_{\mbox{w}}\f$: \f$ \mbox{w} = \{\vec{x}:\ \vec{n}_{\mbox{w}} \cdot \vec{x} = p_{\mbox{w}} \}\f$
-# global variables:  for details refer to MD class documentation.
	- time \f$ t \f$, 
-# parameters for particle \f$ \mbox{P}_i \f$ : for details refer to CParticle class documentation
	- radius \f$ a_i \f$, 
	- mass \f$ m_i = \frac{4}{3} \pi a_i^3 \f$, 
	- inertia \f$ I_i = \frac{2}{5} m_i \f$,
 	- normal spring constant \f$ k \f$ (globally set)
	- normal dissipation coefficient \f$ \gamma \f$, 
	- tangential dissipation coefficient \f$ \gamma^t \f$, 
	- Coulomb friction coefficient \f$ \mu \f$
-# variables for particle \f$ \mbox{P}_i \f$: for details refer to CParticle class documentation
	- position \f$ \vec{r}_i(t)\f$,
	- velocity \f$ \vec{v}_i(t)\f$,
 	- angle \f$ \vec{\alpha}_i(t)\f$, 
 	- angular velocity \f$ \vec{\omega}_i(t)\f$.
-# initial values:
	- position \f$ \vec{r}_i(0) = \vec{r}_i^0 \f$, 
	- velocity \f$ \vec{v}_i(0) = \vec{v}_i^0 \f$, 
	- angle \f$ \vec{\alpha}_i(0)=\vec{0} \f$, 
	- angular velocity \f$ \vec{\omega}_i(0) = \vec{\omega}_i^0 \f$.
-# variables for each collision between particles \f$\mbox{P}_i\f$ and \f$\mbox{P}_j\f$:
 	- relative position \f$ \vec{r}_{ij} = \vec{r}_i - \vec{r}_j \f$,
	- normal direction \f$ \vec{n}_{ij} = \frac{\vec{r}_{ij}}{\|\vec{r}_{ij}\|}\f$,
 	- overlap \f$ \delta_{ij} = (\vec{a}_i - \vec{a}_j) - \vec{r}_{ij}\f$,
 	- relative velocity \f$ \vec{v}_{ij}=\vec{v}_i-\vec{v}_j + (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_i + (a_j-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_j \f$
 	- relative normal velocity \f$ v_{ij}^n = - \vec{v}_{ij} \cdot \vec{n}_{ij}$ ($= \dot{\delta}_{ij} \f$),
 	- normal force (spring-dashpot model) \f$ f_{ij}^n = k \delta_{ij} + \gamma v_{ij}^n \f$,
 	- relative tangential velocity \f$ \vec{v}_{ij}^t = \vec{v}_{ij} - v_{ij}^n \vec{n}_{ij} \f$,
 	- tangential direction \f$ \vec{t}_{ij} = \frac{\vec{v}_{ij}^t}{\|\vec{v}_{ij}^t\|}\f$,
 	- tangential force (sliding friction model) \f$ f_{ij}^t = - \max( \gamma^t v_{ij}^t,\ \mu f_{ij}^n)\f$,
 	- collision force \f$ \vec{f}_{ij} = f_{ij}^n \vec{n}_{ij} + f_{ij}^t \vec{t}_{ij},\ \mbox{if } \delta_{ij}\leq 0,\ 0\  \mbox{else} \f$,
-# Variables for collisions between particle \f$ \mbox{P}_i \f$ and wall \f$ \mbox{w}_j \f$:
	- normal direction \f$ \vec{n}_{ij}^{wall} = - \vec{n}_{\mbox{w}_j}\f$,
 	- overlap \f$ \delta_{ij}^{wall} = \vec{a}_i - (p_{\mbox{w}_j} - n_{\mbox{w}_j} \cdot x)\f$,
 	- relative velocity \f$ \vec{v}_{ij}^{wall}=\vec{v}_i + (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_i \f$,
 	- all else is the same as for particle collisions
-# Force and torque calculations
\f[
\vec{f}_i = m_i \vec{g} + \sum_{j=1}^N \vec{f}_{ij} + \sum_{j=1}^{N_{wall}} \vec{f}_{ij}^{wall},
\f]
\f[
 \vec{t}_i = \sum_{j=1}^N (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{f}_{ij} + \sum_{j=1}^{N_{wall}} (a_i-\frac{\delta_{ij}^{wall}}{2}) \vec{n}_{ij}^{wall} \times \vec{f}_{ij}^{wall}.
\f]
-# Time integration
\f[
\vec{\dot{r}}_i = \vec{v}_i,\ m_i \vec{\dot{v}}_i = \vec{f}_i,\quad 
 \vec{\dot{\alpha}}_i = \vec{\omega}_i,\ I_i \vec{\dot{\omega}}_i = \vec{t}_i
\f]

\section Implementation Implementation
\subsection TimeStepping Time Stepping
Verlet integration for \f$ \vec{r}_i \f$, forward Euler for \f$ \vec{\alpha}_i \f$, \f$ \vec{\omega}_i \f$, fixed time step \f$ dt \f$.
*/

/*! \page Tutorials Fun with MercuryDPM (Guide for tutorials)
The idea behind these tutorials, listed below, is to help the user improve his/her rapport with coding and problem solving in MercuryDPM. Most of the tutorials are designed to solve a simple problem. Each tutorial illustrates a new feature of MercuryDPM and gradually builds up on its level of difficulty.\n
\n
Note: In case of any typos or suggestions for new tutorials, please do not hesitate to contact the MercuryDPM team.

\section T1 T1: Particle motion in outer space
\image html Tutorials/T1/T1_fig1_particle.jpg Particle moving with a constant velocity in outer space.
###Problem description: 
File \b T1.cpp is setup to simulate a particle moving with a constant velocity in the absence of gravity, i.e. \f$ g= 0 m/s^2\f$. Below we describe each bit of the \b T1.cpp in detail.\n

###Headers:
To setup this problem code, below are the necessary headers (from the kernel) and the standard libraries, we include in \b T1.cpp. 
\snippet Drivers/Tutorials/T1.cpp T1:headers
Details concerning the above included headers (from the kernel) can be found in

###Class Tutorial1:
A class named \a Tutorial1 inherits from \a Mercury3D and is defined as below
\snippet Drivers/Tutorials/T1.cpp T1:class
The below function creates and sets up  the problems’ initial conditions
\code void setupInitialConditions()\endcode

###How to create a particle?
A particle is created and copied in a manner shown below
\snippet Drivers/Tutorials/T1.cpp T1:createParticle
\a p0 is an instance of the class \a BaseParticle and its properties like radius, initial position and velocity are set as above. The bit \code particleHandler.copyAndAddObject(p0)\endcode creates the particle \a p0 and adds a copy of it needed for the simulation.

###Main function:
In the main function, 
\# Problem properties, such as gravity, spatial dimensions (x,y,z), total run time are set as below
\snippet Drivers/Tutorials/T1.cpp T1:problemSetup
\# A particle can be of any type. There exist a variety of particle types, e.g. glass, plastic etc. Each of them behave differently when in action. Initially, when a particle is created, it attains the properties of a default species type with ‘0’ as its index. However, one can changes the species properties, as below.
\snippet Drivers/Tutorials/T1.cpp T1:speciesProp
\# Data output is vital to analyse simulations, which leads to defining ways to save the simulation data for post processing.\n
The simulations generate several types of data files. See \ref OutputFiles.\n
Below we set the flags corresponding to each data file type.
\snippet Drivers/Tutorials/T1.cpp T1:output
\# For XBalls users, additional display options can be set as below
\snippet Drivers/Tutorials/T1.cpp T1:visualOutput  
\# After all the simulation parameters are set, we reach a point where we put all the above bits of code in action by the following statements
\snippet Drivers/Tutorials/T1.cpp T1:solve
To see the above snippets as a whole, goto \ref T1code

\section T2 T2: Particle motion on earth
\image html Tutorials/T2/T2_fig1_particle.jpg Particle falling due to gravity.
####Problem descritpion:
In \b T2.cpp, we simulate a particle when dropped under the influence of gravity, \f$ g = 9.81 m/s^2\f$. Basically this is an extension of \b T1.cpp with few minor changes. All we need to do is change the following \n
- initial particle position and velocity in Class Tutorial2
\code
p0.setPosition(0.5*getXMax(),0.5*getYMax(),getZMax());
p0.setVelocity(Vec3D(0.0,0.0,0.0));
\endcode
- gravity vector in the main function of \b T2.cpp
\code
problem.setGravity(Vec3D(0.0,0.0,-9.81));
\endcode

To see the whole code with the above snippets included, goto \ref T2code

\section T3 T3: Bouncing ball (elastic)
\image html Tutorials/T3/T3_fig1_particle_wall.jpg Particle bouncing off the blue wall.
####Problem description: 
In \b T3.cpp, we simulate a particle bouncing off a wall assuming the collision between the particle and the wall is elastic. By elastic we mean that the particle velocity before and after collision remains the same. Implying that the restitution coefficient is unity. Additionally, we will learn how to add a wall over which the ball bounces.

####Headers:
\snippet Drivers/Tutorials/T3.cpp T3:headers
In order to add a wall to our problem setup we need to consider including the header 
\code #include “Walls/InfiniteWall.h” \endcode

#### Class Tutorial3:
\snippet Drivers/Tutorials/T3.cpp T3:class
The above class is basically an extension when compared to Class Tutorial1 or Class Tutorial2. Only difference being the addition of the wall which is done as shown in the snippet below
\snippet Drivers/Tutorials/T3.cpp T3:infiniteWall
The above set of statements, create and place the wall at \f$ Z_{min} \f$.\n 

Note: Don’t forget to include the InfiniteWall.h header, as shown in the header section. In some sense, creation and addition of a wall is similar to creation and addition of a particle.

#### Main function:
As usual, the problem is setup in the main function, see \ref T3code.

\section T4 T4: Bouncing ball with dissipation (inelastic)

####Problem description:
In \b T4.cpp, the difference between an elastic and inelastic collision between a particle and a wall is illustrated. The only difference between \b T3.cpp and \b T4.cpp is the value of the restitution coefficient. In \b T4.cpp, the coefficient of restitution is set to
\code double rc = 0.88; // restitution coefficient \endcode
See \ref T4code for more details.

\section T5 T5: Elastic collision (2 particles)
\image html Tutorials/T5/T5_fig1_two_particles.jpg Particles moving towards each other.
####Problem description:
So far, in the above tutorials, we have seen how a particle and a wall interact during a collision.\n
In this tutorial, we illustrate how two particles interact using \b T5.cpp. For this purpose, we need two particles.\n
The particles may or may not be of the same species type. But, here we shall assume they are of same species and same size.\n
As usual, we begin with including the required headers
####Headers:
\snippet Drivers/Tutorials/T5.cpp T5:headers

####Class Tutorial5:
\snippet Drivers/Tutorials/T5.cpp T5:class
On comparison between the above class and Class Tutorial1, we see how an additional particle is added. In the above class, in function 
\code void setupParticleInitialConditions(){} \endcode
two particles are created, and positioned oppositely apart at a certain distance between them. Both the particles, have a certain velocity directing them towards each other. 

####Main function:
Similar to \b T1.cpp, the problem is setup in \ref T5code

\section T6 T6: Elastic collisions with periodic boundaries
\image html Tutorials/T6/T6_fig1_perboun_two_particles.jpg (a) Illustrates the idea behind periodic boundaries, particle exiting boundary b2 re-enters through boundary b1 \n (b) Illustrates the problem setup.
####Problem description:
In the previous tutorial, we illustrated elastic collision between two particles of same type and size traveling towards each other.\n
In order to have multiple collisions, in the problem setup as Tutorial 5, we will use periodic boundaries in X.

####Headers:
\snippet Drivers/Tutorials/T6.cpp T6:headers
Above are the headers necessary for this problem.

####Class Tutorial6:
\snippet Drivers/Tutorials/T6.cpp T6:class
In the Class Tutorial6\n
(i) we create two particles of same type and different sizes.\n
(ii) we setup periodic boundaries in X-direction as
\snippet Drivers/Tutorials/T6.cpp T6:periodicBoundary

Note:\n
To create periodic boundaries one has to include the header ‘Boundaries/PeriodicBoundary.h’.\n
Be aware that the periodic boundary is not the same as an infinite wall.

####Main function:
Similar to \b T5.cpp, the problem is setup to solve, see \ref T6code

\section T7 T7: Motion of a particle in a two dimensional (2D) box
\image html Tutorials/T7/T7_fig1_particle_2Dbox.jpg Particle motion in a box (blue and black denote the walls).
####Problem description:
In previous tutorials, we have seen how a particle interacts with a wall and itself. In this tutorial, we will learn to design boxes of different shapes by using more than one wall. As an example, in absence of gravity, we will simulate a particle moving in a two dimensional square shaped box. We consider two dimensions only for the sake of simplicity.  

In Tutorial 3, we have shown you how to setup a wall. This tutorial builds itself on the same idea i.e. setting up walls.
####Headers:
\snippet Drivers/Tutorials/T7.cpp T7:headers
We use the same headers as used in Tutorial 3.

####Class Tutorial7:
\snippet Drivers/Tutorials/T7.cpp T7:class
In this class, we setup a 2D square shaped box or a polygon by adding more walls as shown above. In total, we have 4 walls forming our box within which the particle will traverse.

Note: As we simulate in 2D, no walls are set in z-direction.

####Main function:
As our simulation is two dimensional, we set the system dimensions as 2
\code problem.setSystemDimensions(2);\endcode

Complete code for the above problem description can be found in \ref T7code
 
\section T8 T8: Motion of a particle in a box with an obstacle
\image html Tutorials/T8/T8_fig1_particle_2Dbox_obstacle.jpg
####Problem description:
We extend the problem setup of Tutorial 7, by adding a rectangular block as shown in the above figure. To create this block of wall or obstacle, we will use the Class FiniteWall. Before we go ahead it is advised to know the difference between an infinite wall and finite wall, see \ref WallTypes. As an example, we create an obstacle using a set of finite walls and place it within the box created using a set of infinite walls. See the above figure.
####Headers:
\snippet Drivers/Tutorials/T8.cpp T8:headers
####Class Tutorial8:
\image html Tutorials/T8/T8_fig2_finitewall.jpg
The class Tutorial7 from the previous tutorial is extended by adding the finite wall setup. See the below snippet.
\snippet Drivers/Tutorials/T8.cpp T8:finiteWall
####Main function:
Similar to Tutorial 7, the above described problem is setup in \ref T8code

\section T9 T9: Motion of a ball over an inclined plane (Sliding + Rolling)
\image html Tutorials/T9/T9_fig1_particle_slid_roll_incline.jpg

####Problem description:
####Headers:
####Class Tutorial9:
####Main function:

\page Tcodes Codes for tutorials 

\section T1code Particle motion in outer space (code)
Return to tutorial \ref T1
\includelineno Drivers/Tutorials/T1.cpp
Return to tutorial \ref T1

\section T2code Particle motion on earth (code)
Return to tutorial \ref T2
\includelineno Drivers/Tutorials/T2.cpp
Return to tutorial \ref T2

\section T3code Bouncing ball - elastic (code)
Return to tutorial \ref T3
\includelineno Drivers/Tutorials/T3.cpp
Return to tutorial \ref T3

\section T4code Bouncing ball - inelastic (code)
Return to tutorial \ref T4
\includelineno Drivers/Tutorials/T4.cpp
Return to tutorial \ref T4

\section T5code Elastic collision - 2 particles (code)
Return to tutorial \ref T5
\includelineno Drivers/Tutorials/T5.cpp
Return to tutorial \ref T5

\section T6code Elastic collisions with periodic boundaries (code)
Return to tutorial \ref T6
\includelineno Drivers/Tutorials/T6.cpp
Return to tutorial \ref T6

\section T7code Motion of a particle in a two dimensional box (code)
Return to tutorial \ref T7
\includelineno Drivers/Tutorials/T7.cpp
Return to tutorial \ref T7

\section T8code Motion of a particle in a box with an obstacle (code)
Return to tutorial \ref T8
\includelineno Drivers/Tutorials/T8.cpp
Return to tutorial \ref T8

\section T9code Motion of a ball over an inclined plane (code)
Return to tutorial \ref T9
\includelineno Drivers/Tutorials/T9.cpp
Return to tutorial \ref T9

\page WallTypes Different types of walls
Walls are crucial in most of our problem setups and hence we have a variety of walls to suit the needs of our users.
\section InfWall Infinite Wall
\image html Walls/infiniteWall.jpg Infinite wall
A standard wall is a plane defined  as {x: normal*x=position}, with normal being the outward unit normal vector of the wall. A particle touches a standard wall if position-normal*x<=radius. Given the normal, a wall can be placed at any given position.\n
The black strip denotes the inner side of the wall. The particles interact with the wall along the blue strip.  
\section FinWall Finite Wall
\image html Walls/finiteWall.jpg A block of wall formed by set of infinite walls.
Finite wall is basically a set of infinite walls or A finite wall is convex polygon defined by a set of normals normal_i and positions position_i. For example, to create a polygonal obstacle (in 2D or 3D), we consider the a set of infinite walls and create the obstacle as an intersection of all the infinite walls. See above figure corresponding to finite walls. 
*/
