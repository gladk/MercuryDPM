/** \mainpage Reference documentation of Mercury - MD

MercuryDPM is a code for discrete particle simulations.\n
To find the documentation of MercuryDPM, click on the tabs above.\n
You can find more information at http://mercurydpm.org/

See also:
	- \ref output_files
	- \ref introduction_to_the_code_page

\page output_files Output Files

MercuryDPM creates three output files, $name.data, $name.fstat and $name.ene.
Here, $name stands for the problem name defined in the code.
Data is written at predefined time steps. 

Format of $name.data: This file is used for plotting particles. For each time step, the following format is used:
\verbatim
  First Line: N, time, xmin, ymin, zmin, xmax, ymax, zmax
  N Lines: x, y, z, vx, vy, vz, rad, q1, q2, q3, omex, omey, omez, xi
\endverbatim
where \p N is the number of particles,
  - \p time denotes the time step,
  - \p xmin, \p ymin, \p zmin, \p xmax, \p ymax, \p zmax denote the domain size,
  - \p x, \p y, \p z are the coordinates,
  - \p vx, \p vy, \p vz are the volocities,
  - \p rad is the radius,
  - \p q1, \p q2, \p q3 is the angular position,
  - \p omex, \p omey, \p omez is the angular velocity,
  - and \p xi is an additional variable the user can specify (default 0)

This is the (standard) output required for 3D data; for 2D data, only seven columns of particle information is written: x, y, z, vx, vy, vz, rad, xi

Format of $name.fstat: This file is mainly used for calculating stresses. For each time step, the following format is used:
\verbatim
  # time, info
  # info
  # info
  Line per contact: time, i, j, x, y, z, delta, deltat, fn, ft, nx, ny, nz, tx, ty, tz
\endverbatim
with time step time,
  - particle number \p i,
  - contact partner \p j (particles >= 0, walls < 0),
  - the contact point \p x, \p y, \p z,
  - overlap at the contact \p delta,
  - length of the tangential spring \p deltat,
  - absolute normal force \p |f^n|,
  - absolute tangential force \p |f^t|=|f-f^n|,
  - normal unit vector \p nx, \p ny, \p nz,
  - tangential unit vector \p tx, \p ty, \p tz.

Format of $name.ene: This file is mainly used for interpreting the time evolution. For each time step, the following format is used:
\verbatim
  time ene_gra ene_kin ene_rot ene_ela X_COM Y_COM Z_COM
\endverbatim
with
  - ene_gra \f$= \sum_i m_i Dot([x,y,z],-[gx,gy,gz])\f$ the gravitational potential energy (with gravity g=[gx,gy,gz]),
  - ene_kin \f$= \sum_i m_i v_i^2 / 2\f$ the translational kinetic energy,
  - ene_rot \f$= \sum_i I_i \omega_i^2 / 2\f$ the rotational kinetic energy (with inertia I),
  - ene_ela \f$= \sum_i (k_i \delta_i^2 + k_i^t (\delta_i^t)^2) / 2\f$ the potential energy from contact forces,  
  - X_COM, Y_COM, Z_COM the center of mass

\page introduction_to_the_code_page Introduction to the Code

\section SECTION_InfoUsers Information for users of this application

\subsection SUBSECTION_GeneralInfo General Information

This code is written in C++ and does make use of both templates and the object oriented nature of C++. This basic architecture is to have a core kernel code (located in scr) that is general and flexible and then very small driver codes (located in DRIVERS) that pick out the parts of the kernel required to solve specific problems. 

\ref introduction_to_the_code_page 

\page introduction_to_the_code_page Introduction to the Code

\section SECTION_HowToUse How to use this documentation

\section SECTION_InfoUsers Information for users of this application

\subsection SUBSECTION_GeneralInfo General Information

This code is written in C++ and does make use of both templates and the object oriented nature of C++. This basic architecture is to have a core kernel code (located in scr) that is general and flexible and then very small driver codes (located in DRIVERS) that pick out the parts of the kernel required to solve specific problems. 

\subsection SUBSECTION_DirUsers Directory Structure

At the top level you will find six main directories \n
	DRIVERS/ \n
	scr/ \n
	Documentation/ \n
	conf/ \n
	xballs/ \n
	scripts/

In the Documentation directory is located the documentation, i.e. this file. Please note, if you find no documentation there it can be generated by going into the DRIVERS/ direction and typing "make doc". If the documentation becomes corrupt the following will force it to regenerate "make docClean; make doc"

The scr direction contains the heart of the code and as a users you should not need to known much about it.

The DRIVERS directory has a series of subdirectories for example Simple_MD/ that each contain a series of demo codes illustrating how to use the main src code. Typing "make fulltest" in the top level of drivers would perform checks on all parts of the code to confirm everything is functioning as intended.

Finally running a code will (in general) generate four files called some_name.data, some_name.xballs, some_name.stat. and some_name.ene. The files with .data extension contain all the position and velocity information for every particles. The .stat extension, contains macroscopic statistics about the problem (the information contained is semi-driver dependent). The .ene file contain some basic bulk information about the system i.e. centre of mass, total kinetic energy, total potential energy, etc. Finally .xballs extension is an a script file that to run to plot for .data output file using xballs.

\subsection SUBSECTION_TheScripts The Scripts

The directory contains a full scripts that are used by the selftest suite of MercuryDPM. You need worry about the contains of this directory at all; however, for the interested reader
- fpdiff.py : Calculated the floating point different between number in text file. This is part of the internal working of the selftest routine. This original version of this code was created for the oomph-lib project at  the University of Manchester.
- self_test : Makes calls to fpdiff.py passing the locations of newly create data and existing golddata. If writes error logs if something is different between the new data file and the golddata.

\subsection SUBSECTION_DriverDir Creating your own DRIVERS directory for your code

It you look in the DRIVERS directory you will see several subdirectories. These subdirectories contain collections of similar codes and, as a new user, you probably want to create a new directory for your own driver codes. To do this copy the TEMPLATE direction to you YOUR_DIR_NAME (if your are a developer and have access to svn repository it is advisable to svn copy to create your new DRIVERS directory)


\section Variables Variables and Equations 

-# global parameters: for details refer to MD class documentation.
	- time domain \f$[0,t_{\mbox{max}}]\f$, 
	- spatial domain \f$[x_{\mbox{min}},x_{\mbox{max}}] \times [y_{\mbox{min}},y_{\mbox{max}}] \times [z_{\mbox{min}},z_{\mbox{max}}]\f$,
	- number of particles \f$ N \f$,
	- number of (regular) walls \f$ N_{wall}\f$, 
	- number of periodic walls \f$ N_{wall,periodic}\f$
	- gravitational acceleration \f$ \vec{g}\f$,
	- Walls are defined by outward unit normal \f$ \vec{n}_{\mbox{w}}\f$ and position \f$ p_{\mbox{w}}\f$: \f$ \mbox{w} = \{\vec{x}:\ \vec{n}_{\mbox{w}} \cdot \vec{x} = p_{\mbox{w}} \}\f$
-# global variables:  for details refer to MD class documentation.
	- time \f$ t \f$, 
-# parameters for particle \f$ \mbox{P}_i \f$ : for details refer to CParticle class documentation
	- radius \f$ a_i \f$, 
	- mass \f$ m_i = \frac{4}{3} \pi a_i^3 \f$, 
	- inertia \f$ I_i = \frac{2}{5} m_i \f$,
 	- normal spring constant \f$ k \f$ (globally set)
	- normal dissipation coefficient \f$ \gamma \f$, 
	- tangential dissipation coefficient \f$ \gamma^t \f$, 
	- Coulomb friction coefficient \f$ \mu \f$
-# variables for particle \f$ \mbox{P}_i \f$: for details refer to CParticle class documentation
	- position \f$ \vec{r}_i(t)\f$,
	- velocity \f$ \vec{v}_i(t)\f$,
 	- angle \f$ \vec{\alpha}_i(t)\f$, 
 	- angular velocity \f$ \vec{\omega}_i(t)\f$.
-# initial values:
	- position \f$ \vec{r}_i(0) = \vec{r}_i^0 \f$, 
	- velocity \f$ \vec{v}_i(0) = \vec{v}_i^0 \f$, 
	- angle \f$ \vec{\alpha}_i(0)=\vec{0} \f$, 
	- angular velocity \f$ \vec{\omega}_i(0) = \vec{\omega}_i^0 \f$.
-# variables for each collision between particles \f$\mbox{P}_i\f$ and \f$\mbox{P}_j\f$:
 	- relative position \f$ \vec{r}_{ij} = \vec{r}_i - \vec{r}_j \f$,
	- normal direction \f$ \vec{n}_{ij} = \frac{\vec{r}_{ij}}{\|\vec{r}_{ij}\|}\f$,
 	- overlap \f$ \delta_{ij} = (\vec{a}_i - \vec{a}_j) - \vec{r}_{ij}\f$,
 	- relative velocity \f$ \vec{v}_{ij}=\vec{v}_i-\vec{v}_j + (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_i + (a_j-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_j \f$
 	- relative normal velocity \f$ v_{ij}^n = - \vec{v}_{ij} \cdot \vec{n}_{ij}$ ($= \dot{\delta}_{ij} \f$),
 	- normal force (spring-dashpot model) \f$ f_{ij}^n = k \delta_{ij} + \gamma v_{ij}^n \f$,
 	- relative tangential velocity \f$ \vec{v}_{ij}^t = \vec{v}_{ij} - v_{ij}^n \vec{n}_{ij} \f$,
 	- tangential direction \f$ \vec{t}_{ij} = \frac{\vec{v}_{ij}^t}{\|\vec{v}_{ij}^t\|}\f$,
 	- tangential force (sliding friction model) \f$ f_{ij}^t = - \max( \gamma^t v_{ij}^t,\ \mu f_{ij}^n)\f$,
 	- collision force \f$ \vec{f}_{ij} = f_{ij}^n \vec{n}_{ij} + f_{ij}^t \vec{t}_{ij},\ \mbox{if } \delta_{ij}\leq 0,\ 0\  \mbox{else} \f$,
-# Variables for collisions between particle \f$ \mbox{P}_i \f$ and wall \f$ \mbox{w}_j \f$:
	- normal direction \f$ \vec{n}_{ij}^{wall} = - \vec{n}_{\mbox{w}_j}\f$,
 	- overlap \f$ \delta_{ij}^{wall} = \vec{a}_i - (p_{\mbox{w}_j} - n_{\mbox{w}_j} \cdot x)\f$,
 	- relative velocity \f$ \vec{v}_{ij}^{wall}=\vec{v}_i + (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_i \f$,
 	- all else is the same as for particle collisions
-# Force and torque calculations
\f[
\vec{f}_i = m_i \vec{g} + \sum_{j=1}^N \vec{f}_{ij} + \sum_{j=1}^{N_{wall}} \vec{f}_{ij}^{wall},
\f]
\f[
 \vec{t}_i = \sum_{j=1}^N (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{f}_{ij} + \sum_{j=1}^{N_{wall}} (a_i-\frac{\delta_{ij}^{wall}}{2}) \vec{n}_{ij}^{wall} \times \vec{f}_{ij}^{wall}.
\f]
-# Time integration
\f[
\vec{\dot{r}}_i = \vec{v}_i,\ m_i \vec{\dot{v}}_i = \vec{f}_i,\quad 
 \vec{\dot{\alpha}}_i = \vec{\omega}_i,\ I_i \vec{\dot{\omega}}_i = \vec{t}_i
\f]

\section Implementation Implementation
\subsection TimeStepping Time Stepping
Verlet integration for \f$ \vec{r}_i \f$, forward Euler for \f$ \vec{\alpha}_i \f$, \f$ \vec{\omega}_i \f$, fixed time step \f$ dt \f$.

 

*/
