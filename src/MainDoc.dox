/** \mainpage Reference documentation of Mercury - MD

MercuryDPM is a code for discrete particle simulations.\n
To find the documentation of MercuryDPM, click on the tabs above.\n
You can find more information at http://mercurydpm.org/

See also:
	- \ref output_files
	- \ref introduction_to_the_code_page

\page output_files Output Files

MercuryDPM creates three output files, $name.data, $name.fstat and $name.ene.
Here, $name stands for the problem name defined in the code.
Data is written at predefined time steps. 

Format of $name.data: This file is used for plotting particles. For each time step, the following format is used:
\verbatim
  First Line: N, time, xmin, ymin, zmin, xmax, ymax, zmax
  N Lines: x, y, z, vx, vy, vz, rad, q1, q2, q3, omex, omey, omez, xi
\endverbatim
where \p N is the number of particles,
  - \p time denotes the time step,
  - \p xmin, \p ymin, \p zmin, \p xmax, \p ymax, \p zmax denote the domain size,
  - \p x, \p y, \p z are the coordinates,
  - \p vx, \p vy, \p vz are the volocities,
  - \p rad is the radius,
  - \p q1, \p q2, \p q3 is the angular position,
  - \p omex, \p omey, \p omez is the angular velocity,
  - and \p xi is an additional variable the user can specify (default 0)

This is the (standard) output required for 3D data; for 2D data, only seven columns of particle information is written: x, y, z, vx, vy, vz, rad, xi

Format of $name.fstat: This file is mainly used for calculating stresses. For each time step, the following format is used:
\verbatim
  # time, info
  # info
  # info
  Line per contact: time, i, j, x, y, z, delta, deltat, fn, ft, nx, ny, nz, tx, ty, tz
\endverbatim
with time step time,
  - particle number \p i,
  - contact partner \p j (particles >= 0, walls < 0),
  - the contact point \p x, \p y, \p z,
  - overlap at the contact \p delta,
  - length of the tangential spring \p deltat,
  - absolute normal force \p |f^n|,
  - absolute tangential force \p |f^t|=|f-f^n|,
  - normal unit vector \p nx, \p ny, \p nz,
  - tangential unit vector \p tx, \p ty, \p tz.

Format of $name.ene: This file is mainly used for interpreting the time evolution. For each time step, the following format is used:
\verbatim
  time ene_gra ene_kin ene_rot ene_ela X_COM Y_COM Z_COM
\endverbatim
with
  - ene_gra \f$= \sum_i m_i Dot([x,y,z],-[gx,gy,gz])\f$ the gravitational potential energy (with gravity g=[gx,gy,gz]),
  - ene_kin \f$= \sum_i m_i v_i^2 / 2\f$ the translational kinetic energy,
  - ene_rot \f$= \sum_i I_i \omega_i^2 / 2\f$ the rotational kinetic energy (with inertia I),
  - ene_ela \f$= \sum_i (k_i \delta_i^2 + k_i^t (\delta_i^t)^2) / 2\f$ the potential energy from contact forces,  
  - X_COM, Y_COM, Z_COM the center of mass

\page introduction_to_the_code_page Introduction to the Code

\section SECTION_HowToUse How to use this documentation

\section SECTION_InfoUsers Information for users of this application

\subsection SUBSECTION_GeneralInfo General Information

This code is written in C++ and does make use of both templates and the object oriented nature of C++. This basic architecture is to have a core kernel code (located in scr) that is general and flexible and then very small driver codes (located in DRIVERS) that pick out the parts of the kernel required to solve specific problems. 

\ref introduction_to_the_code_page 

\page introduction_to_the_code_page Introduction to the Code

\section SECTION_HowToUse How to use this documentation

\section SECTION_InfoUsers Information for users of this application

\subsection SUBSECTION_GeneralInfo General Information

This code is written in C++ and does make use of both templates and the object oriented nature of C++. This basic architecture is to have a core kernel code (located in scr) that is general and flexible and then very small driver codes (located in DRIVERS) that pick out the parts of the kernel required to solve specific problems. 

\subsection SUBSECTION_DirUsers Directory Structure

At the top level you will find three main directories \n
	DRIVERS/ \n
	scr/ \n
	DOCUMENTATION/

In the DOCUMENTATION direction is located the documentation, i.e. this file. Please note, if you find no documentation there it can be generated by going into the DRIVERS/ direction and typing "make doc". If the documentation becomes corrupt the following will force it to regenerate "make doc_clean; make doc"

The scr direction contains the heart of the code and as a users you should not need to known much about it.

The DRIVERS directory has a series of subdirectories for example Simple_MD/ that each contain a series of demo codes illustrating how to use the main src code. Typing "make selftest" in the top level of drivers would perform checks on all parts of the code to confirm everything is functioning as intended.

In each subdirectory (e.g. Simple_MD) there is a makefile that can be used to compile the individual codes. Note typing "make selftest" at this level will perform the test for that section of the code only. Also in subdirectory they is a second subdirectory call run/. If you move in this directory from here any driver can be run with the command "sc/quick_run driver_name". This command will compile and run driver_name.

Finally running a code will (in general) generate three files called some_name.data, some_name.disp and some_name.stat. The files with .data extension contain all the position and velocity information for every particles. The .stat extension, contains macroscopic statistics about the problem (the information contained is semi-driver dependent). Finally .disp extension is an a script file that to run to plot for .data output file using xballs.

\subsection SUBSECTION_TheScripts The Scripts

Along with this code you will find a directory called scripts. This contains a number of bash scripts designed to work with both the MD and finite volume programs. A brief summary of each script is as follows
- clean_run : The code has a feature to automatically number your runs (not yet documents, see parm_demo code for how to use). So the first time you run the code will be labelled 1, second 2, etc... Running clean_run CODENAME RUN_NUM will delete all files with run number RUN_NUM of driver code CODENAME. This does not prompt for each file, so please be careful with this command.
- fstat : To be documented
- go_run : This is internal script used by run and should not be called directly
- renumber_run : This changes the number of previous run. renumber_run CODENAME OLD_NUM NEW_NUM will change the number of all files associated with CODENAME run number OLD_NUM to be associated with run NEW_NUM. Please note again this command does not check it NEW_RUN exists so will delete any existing data associated with NEW_RUN.
- self_test : This is the script which does the work for 'make selftest'. It should never be called directly, please use make selftest.
- enestatistics : To be documented
- fstatatistics : To be documented
- kill_all : This kills all copies of a code running on a cluster. To use this commands please type the list of machine names on your cluster in the list filed at the top. Note the default list is more machine in the MSM group at the University of Twente
- report : This is the script which does the work of 'make report', please use make report instead of this command directly.
- find_code : This reports all codes belonging to your on your cluster, please again in this script you have to list the machine names of your cluster
- go_find_machine : Looks for spare ca[capacity on your cluster. To use this script please enter you machine list in list and the maxload per machine in maxload.
- make_movie : This script uses xball to make a movie. The command is called with make_movie SOMEFILE.disp, this will make a movie of the xballs output normally generated by the disp file SOMEFILE.disp.
- run : run MY_CODE will make and run the code called MY_CODE. This automatically looks for free space on your cluster using the information defined in go_find_machine
- fpdiff.py : Calculated the floating point different between number in text file. This is part of the internal working of the selftest routire. This original version of this code was created for the oomph-lib project at  the University of Manchester.
- go_make : This is internal script used by run.
- quick_run : Same as run, but runs the code on the local machine.

\subsection SUBSECTION_DriverDir Creating your own DRIVERS directory for your code

It you look in the DRIVERS directory you will see several subdirectories. These subdirectories contain collections of similar codes and, as a new user, you probably want to create a new directory for your own driver codes. To do this copy the TEMPLATE direction to you YOUR_DIR_NAME (if your are a developer and have access to svn repository it is advisable to svn copy to create your new DRIVERS directory)

\section InfoDev Information for developers of this application


\section Variables Variables and Equations 

-# global parameters: for details refer to MD class documentation.
	- time domain \f$[0,t_{\mbox{max}}]\f$, 
	- spatial domain \f$[x_{\mbox{min}},x_{\mbox{max}}] \times [y_{\mbox{min}},y_{\mbox{max}}] \times [z_{\mbox{min}},z_{\mbox{max}}]\f$,
	- number of particles \f$ N \f$,
	- number of (regular) walls \f$ N_{wall}\f$, 
	- number of periodic walls \f$ N_{wall,periodic}\f$
	- gravitational acceleration \f$ \vec{g}\f$,
	- Walls are defined by outward unit normal \f$ \vec{n}_{\mbox{w}}\f$ and position \f$ p_{\mbox{w}}\f$: \f$ \mbox{w} = \{\vec{x}:\ \vec{n}_{\mbox{w}} \cdot \vec{x} = p_{\mbox{w}} \}\f$
-# global variables:  for details refer to MD class documentation.
	- time \f$ t \f$, 
-# parameters for particle \f$ \mbox{P}_i \f$ : for details refer to CParticle class documentation
	- radius \f$ a_i \f$, 
	- mass \f$ m_i = \frac{4}{3} \pi a_i^3 \f$, 
	- inertia \f$ I_i = \frac{2}{5} m_i \f$,
 	- normal spring constant \f$ k \f$ (globally set)
	- normal dissipation coefficient \f$ \gamma \f$, 
	- tangential dissipation coefficient \f$ \gamma^t \f$, 
	- Coulomb friction coefficient \f$ \mu \f$
-# variables for particle \f$ \mbox{P}_i \f$: for details refer to CParticle class documentation
	- position \f$ \vec{r}_i(t)\f$,
	- velocity \f$ \vec{v}_i(t)\f$,
 	- angle \f$ \vec{\alpha}_i(t)\f$, 
 	- angular velocity \f$ \vec{\omega}_i(t)\f$.
-# initial values:
	- position \f$ \vec{r}_i(0) = \vec{r}_i^0 \f$, 
	- velocity \f$ \vec{v}_i(0) = \vec{v}_i^0 \f$, 
	- angle \f$ \vec{\alpha}_i(0)=\vec{0} \f$, 
	- angular velocity \f$ \vec{\omega}_i(0) = \vec{\omega}_i^0 \f$.
-# variables for each collision between particles \f$\mbox{P}_i\f$ and \f$\mbox{P}_j\f$:
 	- relative position \f$ \vec{r}_{ij} = \vec{r}_i - \vec{r}_j \f$,
	- normal direction \f$ \vec{n}_{ij} = \frac{\vec{r}_{ij}}{\|\vec{r}_{ij}\|}\f$,
 	- overlap \f$ \delta_{ij} = (\vec{a}_i - \vec{a}_j) - \vec{r}_{ij}\f$,
 	- relative velocity \f$ \vec{v}_{ij}=\vec{v}_i-\vec{v}_j + (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_i + (a_j-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_j \f$
 	- relative normal velocity \f$ v_{ij}^n = - \vec{v}_{ij} \cdot \vec{n}_{ij}$ ($= \dot{\delta}_{ij} \f$),
 	- normal force (spring-dashpot model) \f$ f_{ij}^n = k \delta_{ij} + \gamma v_{ij}^n \f$,
 	- relative tangential velocity \f$ \vec{v}_{ij}^t = \vec{v}_{ij} - v_{ij}^n \vec{n}_{ij} \f$,
 	- tangential direction \f$ \vec{t}_{ij} = \frac{\vec{v}_{ij}^t}{\|\vec{v}_{ij}^t\|}\f$,
 	- tangential force (sliding friction model) \f$ f_{ij}^t = - \max( \gamma^t v_{ij}^t,\ \mu f_{ij}^n)\f$,
 	- collision force \f$ \vec{f}_{ij} = f_{ij}^n \vec{n}_{ij} + f_{ij}^t \vec{t}_{ij},\ \mbox{if } \delta_{ij}\leq 0,\ 0\  \mbox{else} \f$,
-# Variables for collisions between particle \f$ \mbox{P}_i \f$ and wall \f$ \mbox{w}_j \f$:
	- normal direction \f$ \vec{n}_{ij}^{wall} = - \vec{n}_{\mbox{w}_j}\f$,
 	- overlap \f$ \delta_{ij}^{wall} = \vec{a}_i - (p_{\mbox{w}_j} - n_{\mbox{w}_j} \cdot x)\f$,
 	- relative velocity \f$ \vec{v}_{ij}^{wall}=\vec{v}_i + (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{\omega}_i \f$,
 	- all else is the same as for particle collisions
-# Force and torque calculations
\f[
\vec{f}_i = m_i \vec{g} + \sum_{j=1}^N \vec{f}_{ij} + \sum_{j=1}^{N_{wall}} \vec{f}_{ij}^{wall},
\f]
\f[
 \vec{t}_i = \sum_{j=1}^N (a_i-\frac{\delta_{ij}}{2}) \vec{n}_{ij} \times \vec{f}_{ij} + \sum_{j=1}^{N_{wall}} (a_i-\frac{\delta_{ij}^{wall}}{2}) \vec{n}_{ij}^{wall} \times \vec{f}_{ij}^{wall}.
\f]
-# Time integration
\f[
\vec{\dot{r}}_i = \vec{v}_i,\ m_i \vec{\dot{v}}_i = \vec{f}_i,\quad 
 \vec{\dot{\alpha}}_i = \vec{\omega}_i,\ I_i \vec{\dot{\omega}}_i = \vec{t}_i
\f]

\section Implementation Implementation
\subsection TimeStepping Time Stepping
Verlet integration for \f$ \vec{r}_i \f$, forward Euler for \f$ \vec{\alpha}_i \f$, \f$ \vec{\omega}_i \f$, fixed time step \f$ dt \f$.

 

*/
